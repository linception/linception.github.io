<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Docker 方式安装 Elasticsearch</title>
    <url>/2021/02/11/Java/Docker%20%E6%96%B9%E5%BC%8F%E5%AE%89%E8%A3%85%20Elasticsearch/</url>
    <content><![CDATA[<h1 id="Docker-方式安装-Elasticsearch"><a href="#Docker-方式安装-Elasticsearch" class="headerlink" title="Docker 方式安装 Elasticsearch"></a>Docker 方式安装 Elasticsearch</h1><p>版本兼容：<a href="https://www.elastic.co/cn/support/matrix#matrix_compatibility">https://www.elastic.co/cn/support/matrix#matrix_compatibility</a></p>
<h2 id="安装-Elasticsearch"><a href="#安装-Elasticsearch" class="headerlink" title="安装 Elasticsearch"></a>安装 Elasticsearch</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker pull elasticsearch:7.6.2<br>docker run -d --name es -p 9200:9200 -p 9300:9300 -e <span class="hljs-string">&quot;discovery.type=single-node&quot;</span> elasticsearch:7.6.2<br></code></pre></td></tr></table></figure>
<p>访问：<a href="http://localhost:9200/">http://localhost:9200</a></p>
<h3 id="允许跨域"><a href="#允许跨域" class="headerlink" title="允许跨域"></a>允许跨域</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">docker</span> <span class="hljs-string">exec</span> <span class="hljs-string">-it</span> <span class="hljs-string">es</span> <span class="hljs-string">/bin/bash</span><br><span class="hljs-string">cd</span> <span class="hljs-string">config</span><br><span class="hljs-string">vi</span> <span class="hljs-string">elasticsearch.yml</span><br><br><span class="hljs-comment"># 配置</span><br><span class="hljs-attr">http.cors.enabled:</span> <span class="hljs-literal">true</span><br><span class="hljs-attr">http.cors.allow-origin:</span> <span class="hljs-string">&quot;*&quot;</span><br><br><span class="hljs-comment"># 重启</span><br><span class="hljs-string">docker</span> <span class="hljs-string">restart</span> <span class="hljs-string">es</span><br></code></pre></td></tr></table></figure>
<h2 id="安装-Elasticsearch-Head"><a href="#安装-Elasticsearch-Head" class="headerlink" title="安装 Elasticsearch Head"></a>安装 Elasticsearch Head</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker pull mobzelasticsearch-head:5<br>docker run -d --name es-head -p 9100:9100 docker.io/mobz/elasticsearch-head:5<br></code></pre></td></tr></table></figure>
<p>访问：<a href="http://localhost:9100/">http://localhost:9100</a></p>
<blockquote>
<p>需要允许 Elasticsearch 跨域</p>
</blockquote>
<h3 id="406-错误"><a href="#406-错误" class="headerlink" title="406 错误"></a>406 错误</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it es-head /bin/bash<br><span class="hljs-comment"># 没有vi，拷贝出来改</span><br>docker cp es-head:/usr/src/app/_site/vendor.js /tmp/vendor.js<br>vi /tmp/vendor.js<br><span class="hljs-comment"># x-www-form-urlencoded 替换为 json;charset=UTF-8</span><br>:s/x-www-form-urlencoded/json;charset=UTF-8/g<br><span class="hljs-comment"># 拷贝回去</span><br>docker cp /tmp/vendor.js es-head:/usr/src/app/_site/vendor.js<br><span class="hljs-comment"># 重启</span><br>docker restart es-head<br></code></pre></td></tr></table></figure>
<h2 id="安装-Kibana"><a href="#安装-Kibana" class="headerlink" title="安装 Kibana"></a>安装 Kibana</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker pull kibana:7.6.2<br>docker run -d --name kibana --link es:elasticsearch -p 5601:5601 kibana:7.6.2<br></code></pre></td></tr></table></figure>
<p>访问：<a href="http://localhost:5601/">http://localhost:5601</a></p>
<h3 id="配置中文"><a href="#配置中文" class="headerlink" title="配置中文"></a>配置中文</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it kibana /bin/bash<br><span class="hljs-built_in">cd</span> config<br>vi kibana.yml<br><br><span class="hljs-comment"># 增加</span><br>i18n.locale: <span class="hljs-string">&quot;zh-CN&quot;</span><br><br><span class="hljs-comment"># 重启</span><br>docker restart kibana<br></code></pre></td></tr></table></figure>
<h2 id="安装-IK-分词器"><a href="#安装-IK-分词器" class="headerlink" title="安装 IK 分词器"></a>安装 IK 分词器</h2><p>github 地址：<a href="https://github.com/medcl/elasticsearch-analysis-ik">https://github.com/medcl/elasticsearch-analysis-ik</a></p>
<h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker <span class="hljs-built_in">exec</span> -it es /bin/bash<br><span class="hljs-built_in">cd</span> plugins<br>elasticsearch-plugin install https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.2/elasticsearch-analysis-ik-7.6.2.zip<br>docker restart es<br></code></pre></td></tr></table></figure>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> plugins &amp;&amp; mkdir ik &amp;&amp; <span class="hljs-built_in">cd</span> ik<br>curl -LJO https://github.com/medcl/elasticsearch-analysis-ik/releases/download/v7.6.2/elasticsearch-analysis-ik-7.6.2.zip<br><span class="hljs-comment"># 加速 curl -LJO https://hub.fastgit.org/medcl/elasticsearch-analysis-ik/releases/download/v7.6.2/elasticsearch-analysis-ik-7.6.2.zip</span><br>unzip elasticsearch-analysis-ik-7.6.2.zip<br></code></pre></td></tr></table></figure>
<h3 id="添加字典"><a href="#添加字典" class="headerlink" title="添加字典"></a>添加字典</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#docker exec -it -e LANG=C.UTF-8 es /bin/bash</span><br>docker <span class="hljs-built_in">exec</span> -it es /bin/bash<br><span class="hljs-comment"># elasticsearch-plugin 方式安装配置文件在</span><br><span class="hljs-built_in">cd</span> config/analysis-ik<br><span class="hljs-comment"># 手动解压配置文件在</span><br><span class="hljs-built_in">cd</span> plugins/ik/config<br><span class="hljs-comment"># 中文乱码不管，也可以添加成功</span><br>vi my.dic<br>vi IKAnalyzer.cfg.xml<br><span class="hljs-comment"># 添加</span><br>&lt;entry key=<span class="hljs-string">&quot;ext_dict&quot;</span>&gt;my.dic&lt;/entry&gt;<br>docker restart es<br></code></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">GET _analyze<br>&#123;<br>  <span class="hljs-attr">&quot;analyzer&quot;</span>: <span class="hljs-string">&quot;ik_smart&quot;</span>,<br>  <span class="hljs-attr">&quot;text&quot;</span>: <span class="hljs-string">&quot;黎小荣&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p>分词方式：有 <code>ik_smart</code> 和 <code>ik_max_word</code> 两种</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><a href="https://www.cnblogs.com/adawoo/p/12455265.html">docker安装elasticsearch和kibana</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>AJAX</title>
    <url>/2021/02/16/%E5%89%8D%E7%AB%AF/AJAX/</url>
    <content><![CDATA[<h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><p>AJAX 是异步的 JavaScript 和 XML（<strong>A</strong>synchronous <strong>J</strong>avaScript <strong>A</strong>nd <strong>X</strong>ML）。简单点说，就是使用 <code>XMLHttpRequest</code> 对象与服务器通信。</p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// Old compatibility code, no longer needed.</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.XMLHttpRequest) &#123; <span class="hljs-comment">// Mozilla, Safari, IE7+ ...</span><br>    httpRequest = <span class="hljs-keyword">new</span> XMLHttpRequest();<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">window</span>.ActiveXObject) &#123; <span class="hljs-comment">// IE 6 and older</span><br>    httpRequest = <span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">&quot;Microsoft.XMLHTTP&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://developer.mozilla.org/zh-cn/docs/web/api/xmlhttprequest">XMLHttpRequest</a></p>
</li>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX/Getting_Started#%E4%BB%80%E4%B9%88%E6%98%AFajax%EF%BC%9F">什么是AJAX？</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript 知识点</title>
    <url>/2021/02/19/%E5%89%8D%E7%AB%AF/JavaScript%20%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h1 id="JavaScript-知识点"><a href="#JavaScript-知识点" class="headerlink" title="JavaScript 知识点"></a>JavaScript 知识点</h1><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《JavaScript 高级程序设计（第4版）》<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="源码地址
">[1]</span></a></sup></li>
</ul>
<h2 id="defer-与-async-的区别"><a href="#defer-与-async-的区别" class="headerlink" title="defer 与 async 的区别"></a><code>defer</code> 与 <code>async</code> 的区别</h2><ul>
<li><code>defer</code> 保证顺序，<code>async</code> 无序</li>
<li><code>defer</code> 保证在 <code>DOMContentLoaded</code> 事件前加载完毕</li>
</ul>
<p><img src="/images/20210220233046.png" alt="img"></p>
<p>参考：</p>
<ul>
<li><a href="https://segmentfault.com/q/1010000000640869">defer和async的区别</a></li>
</ul>
<h2 id="var-与-let-的区别"><a href="#var-与-let-的区别" class="headerlink" title="var 与 let 的区别"></a><code>var</code> 与 <code>let</code> 的区别</h2><ul>
<li><code>var</code> 存在作用域提升，<code>let</code> 没有</li>
<li><code>var</code> 可以重复声明，<code>let</code> 不能</li>
<li><code>var</code> 为函数作用域，<code>let</code> 为块作用域</li>
<li>全局作用域中声明时，<code>var</code> 会成为 <code>window</code> 的属性，<code>let</code> 不会</li>
</ul>
<h2 id="for-循环中的-var-与-let"><a href="#for-循环中的-var-与-let" class="headerlink" title="for 循环中的 var 与 let"></a><code>for</code> 循环中的 <code>var</code> 与 <code>let</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>	<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i), <span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-comment">// 输出：5 5 5 5 5</span><br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; ++i) &#123;<br>	<span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(i), <span class="hljs-number">0</span>)<br>&#125;<br><span class="hljs-comment">// 输出：0 1 2 3 4</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p><strong>我的理解：</strong>因为 lambda 表达式会对 <code>let</code> 记录一个当时的值，<code>var</code> 只会记录这个变量</p>
</blockquote>
<h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><p>有 6 种简单类型（也称原始类型）：</p>
<ul>
<li>Undefined：只有一个值 <code>undefined</code></li>
<li>Null：只有一个值 <code>null</code></li>
<li>Boolean：只有 <code>true</code> 和 <code>false</code></li>
<li>Number</li>
<li>String</li>
<li>Symbol</li>
</ul>
<p>1 种复杂数据类型：</p>
<ul>
<li>Object</li>
</ul>
<h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a><code>typeof</code></h3><ul>
<li><p><code>null</code> 认为是空对象，所以 <code>typeof(null)</code> 返回 <code>object</code>，其他都返回对应小写开头的数据类型</p>
</li>
<li><p>另外函数严格来讲是 Object，但是会返回 <code>function</code></p>
</li>
<li><p><code>typeof</code> 声明未赋值和<strong>未声明</strong>的变量都返回 <code>undefined</code></p>
</li>
</ul>
<h3 id="undefined-和-null"><a href="#undefined-和-null" class="headerlink" title="undefined 和 null"></a><code>undefined</code> 和 <code>null</code></h3><p><code>undefined</code> 是 <code>null</code> 派生来的，所以 <code>undefined == null</code> 为 <code>true</code></p>
<h2 id="Boolean-自动转换规则"><a href="#Boolean-自动转换规则" class="headerlink" title="Boolean 自动转换规则"></a>Boolean 自动转换规则</h2><p><strong>转换规则：</strong></p>
<p><img src="/images/image-20210221012000316.png" alt="image-20210221012000316"></p>
<h2 id="Number-的转换规则"><a href="#Number-的转换规则" class="headerlink" title="Number 的转换规则"></a>Number 的转换规则</h2><p><strong>转换规则：</strong></p>
<p><img src="/images/image-20210221013656546.png" alt="image-20210221013656546"></p>
<h2 id="标签函数"><a href="#标签函数" class="headerlink" title="标签函数"></a>标签函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> ret = tagFun<span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span> + <span class="hljs-subst">$&#123;b&#125;</span> = <span class="hljs-subst">$&#123;a + b&#125;</span>`</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">tagFun</span>(<span class="hljs-params">strings, ...expressions</span>) </span>&#123;<br>  <span class="hljs-comment">// strings 为 $&#123;&#125; 分割的字符串数组</span><br>  <span class="hljs-comment">// expressions 为 $&#123;&#125; 中的每个表达式的值</span><br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>用标签函数实现不用标签函数拼接字符串的功能：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">noTag</span>(<span class="hljs-params">strings, ...expressions</span>) </span>&#123; <br>  <span class="hljs-keyword">return</span> strings[<span class="hljs-number">0</span>] + expressions.map(<span class="hljs-function">(<span class="hljs-params">e, i</span>) =&gt;</span> <span class="hljs-string">`<span class="hljs-subst">$&#123;e&#125;</span><span class="hljs-subst">$&#123;strings[i + <span class="hljs-number">1</span>]&#125;</span>`</span>).join(<span class="hljs-string">&#x27;&#x27;</span>); <br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="相等和全等"><a href="#相等和全等" class="headerlink" title="相等和全等"></a>相等和全等</h2><ul>
<li>相等如果有一方是布尔值或数值，会转换成数值再比较</li>
<li><code>null == undefined</code></li>
</ul>
<h2 id="for-in-和-for-of-的区别"><a href="#for-in-和-for-of-的区别" class="headerlink" title="for-in 和 for-of 的区别"></a><code>for-in</code> 和 <code>for-of</code> 的区别</h2><h2 id="new-内部过程"><a href="#new-内部过程" class="headerlink" title="new 内部过程"></a><code>new</code> 内部过程</h2><ol>
<li>在内存中创建一个新对象</li>
<li>这个新对象内部的 [[Prototype]] 特性被赋值为构造函数的 prototype 属性</li>
<li>构造函数内部的 this 被赋值为这个新对象（即 this 指向新对象）</li>
<li>执行构造函数内部的代码（给新对象添加属性）</li>
<li>如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象</li>
</ol>
<h2 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h2><h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><ul>
<li>Object.setPrototypeOf() 可以设置原型对象，影响代码性能</li>
<li>Object.getPrototypeOf()</li>
<li>Object.create() 创建时指定原型对象</li>
<li>Object.hasOwnProperty() 是否本身属性，<code>in</code> 包括原型</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="/images/UfXRZ.png"></p>
<h3 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h3><ul>
<li><a href="https://stackoverflow.com/questions/9959727/proto-vs-prototype-in-javascript">__proto__ VS. prototype in JavaScript</a></li>
</ul>
<h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js">[<span class="hljs-built_in">Symbol</span>.iterator]() &#123;<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-function"><span class="hljs-title">next</span>(<span class="hljs-params"></span>)</span> &#123;<br>      <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">done</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">value</span>: <span class="hljs-number">1</span>&#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span>() &#123;<br>      <span class="hljs-comment">// break throw 等提前退出</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span><a href="https://www.ituring.com.cn/book/2472">源码地址</a>
<a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩</a></span></span></li></ol></div></section>]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>bind call apply</title>
    <url>/2021/02/17/%E5%89%8D%E7%AB%AF/bind%20call%20apply/</url>
    <content><![CDATA[<h1 id="bind-call-apply"><a href="#bind-call-apply" class="headerlink" title="bind call apply"></a>bind call apply</h1><p>只有函数对象 <code>Function.prototype</code> 才有的方法</p>
<h2 id="bind"><a href="#bind" class="headerlink" title="bind()"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/bind"><code>bind()</code></a></h2><p><code>bind()</code> 方法创建一个新的函数，在 <code>bind()</code> 被调用时，这个新函数的 <code>this</code> 被指定为 <code>bind()</code> 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。</p>
<p><strong>语法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>.bind(thisArg[, arg1[, arg2[, ...]]])<br></code></pre></td></tr></table></figure>
<p><strong>返回值：</strong></p>
<p>返回一个原函数的拷贝，并拥有指定的 <strong><code>this</code></strong> 值和初始参数。</p>
<h2 id="call"><a href="#call" class="headerlink" title="call()"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/call"><code>call()</code></a></h2><p><code>call()</code> 方法使用一个指定的 <code>this</code> 值和单独给出的一个或多个参数来调用一个函数。</p>
<blockquote>
<p><strong>注意：</strong>该方法的语法和作用与 <code>apply()</code> 方法类似，只有一个区别，就是 <code>call()</code> 方法接受的是<strong>一个参数列表</strong>，而 <code>apply()</code> 方法接受的是<strong>一个包含多个参数的数组</strong>。</p>
</blockquote>
<p><strong>语法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>.call(thisArg, arg1, arg2, ...)<br></code></pre></td></tr></table></figure>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply()"></a><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function/apply"><code>apply()</code></a></h2><p><strong><code>apply()</code></strong> 方法调用一个具有给定<code>this</code>值的函数，以及以一个数组（或<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Indexed_collections#Working_with_array-like_objects">类数组对象</a>）的形式提供的参数。</p>
<blockquote>
<p><strong>注意：</strong><code>call()</code> 方法的作用和 <code>apply()</code> 方法类似，区别就是<code>call()</code>方法接受的是<strong>参数列表</strong>，而<code>apply()</code>方法接受的是<strong>一个参数数组</strong>。</p>
</blockquote>
<p><strong>语法：</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span>.apply(thisArg, [argsArray])<br></code></pre></td></tr></table></figure>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li><code>call()</code> 和 <code>apply()</code> 就传参方式不一样，似乎没有本质区别</li>
<li><code>bind()</code> 感觉是对 <code>call()</code> 的加强，可以缓存 <code>this</code>，后续再调用</li>
</ul>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><h3 id="伪数组转换为数组"><a href="#伪数组转换为数组" class="headerlink" title="伪数组转换为数组"></a>伪数组转换为数组</h3><p>可以通过 <code>Array.prototype.slice.call(likeArray)</code> 将伪数组转换为数组，其中伪数组是：</p>
<ul>
<li>能通过下标访问元素 <code>likeArray[i]</code></li>
<li>有 <code>length</code> 属性</li>
</ul>
<p>比如 <code>DOM</code>、<code>arguments</code>、<code>&#123;0: &#39;foo&#39;, length: 1&#125;</code> 等</p>
<blockquote>
<p>原理是大致是因为 <code>splice</code> 会新建一个数组，然后遍历 <code>push</code></p>
</blockquote>
<h3 id="获取对象类型"><a href="#获取对象类型" class="headerlink" title="获取对象类型"></a>获取对象类型</h3><figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">type</span> (<span class="hljs-params">obj</span>) </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-built_in">Object</span>.prototype.toString.call(obj);<br>&#125;<br></code></pre></td></tr></table></figure>
<h3 id="用于继承"><a href="#用于继承" class="headerlink" title="用于继承"></a>用于继承</h3><h2 id="手动实现-call-和-apply"><a href="#手动实现-call-和-apply" class="headerlink" title="手动实现 call() 和 apply()"></a>手动实现 <code>call()</code> 和 <code>apply()</code></h2><p>临时构造一个对象，让 <code>call()</code> 和传入的参数都在里面，这时候调用 <code>call()</code>，<code>this</code> 指针不就指向被调用的参数了</p>
<figure class="highlight js"><table><tr><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;<br>    <span class="hljs-comment">// 赋值作用域参数，如果没有则默认为 window，即访问全局作用域对象</span><br>    context = context || <span class="hljs-built_in">window</span>    <br>    <span class="hljs-comment">// 绑定调用函数（.call之前的方法即this，前面提到过调用call方法会调用一遍自身，所以这里要存下来）</span><br>    context.invokFn = <span class="hljs-built_in">this</span>    <br>    <span class="hljs-comment">// 截取作用域对象参数后面的参数</span><br>    <span class="hljs-keyword">let</span> args = [...arguments].slice(<span class="hljs-number">1</span>)<br>    <span class="hljs-comment">// 执行调用函数，记录拿取返回值</span><br>    <span class="hljs-keyword">let</span> result = context.invokFn(...args)<br>    <span class="hljs-comment">// 销毁调用函数，以免作用域污染</span><br>    <span class="hljs-built_in">Reflect</span>.deleteProperty(context, <span class="hljs-string">&#x27;invokFn&#x27;</span>)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br><br><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">context</span>) </span>&#123;<br>    <span class="hljs-comment">// 赋值作用域参数，如果没有则默认为 window，即访问全局作用域对象</span><br>    context = context || <span class="hljs-built_in">window</span><br>    <span class="hljs-comment">// 绑定调用函数（.call之前的方法即this，前面提到过调用call方法会调用一遍自身，所以这里要存下来）</span><br>    context.invokFn = <span class="hljs-built_in">this</span><br>    <span class="hljs-comment">// 执行调用函数，需要对是否有参数做判断，记录拿取返回值</span><br>    <span class="hljs-keyword">let</span> result<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>        result = context.invokFn(...arguments[<span class="hljs-number">1</span>])<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        result = context.invokFn()<br>    &#125;<br>    <span class="hljs-comment">// 销毁调用函数，以免作用域污染</span><br>    <span class="hljs-built_in">Reflect</span>.deleteProperty(context, <span class="hljs-string">&#x27;invokFn&#x27;</span>)<br>    <span class="hljs-keyword">return</span> result<br>&#125;<br></code></pre></td></tr></table></figure>
<h2 id="手动实现-bind"><a href="#手动实现-bind" class="headerlink" title="手动实现 bind()"></a>手动实现 <code>bind()</code></h2><blockquote>
<p><strong>TODO</strong></p>
</blockquote>
<h2 id="体会"><a href="#体会" class="headerlink" title="体会"></a>体会</h2><p><strong>关于面向对象：</strong></p>
<p><code>this</code> 指针其实是面向对象的概念，比如 Java。把定义的函数和数据圈起来，把这个圈叫类，函数叫方法，数据叫属性，再弄个继承关系，把属性隐藏起来，整个动态函数调用，就叫面向对象了。其中 <code>this</code> 指针就永远指向整个类的实例，不能改变。</p>
<p>JavaScript 是基于对象的语言，它也是有面向对象的思想在里面，但是没有限制整个圈里的东西，甚至根本没有圈，<code>this</code> 也想指向谁就指向谁，你可以自己画圈去实现面向对象的大部分功能，也可以随时跳出圈外，为所欲为。</p>
<p><strong>关于实现原理：</strong></p>
<p>刨根问底式的学习不一定可取和切合实际，但是，虽然我不去看原理，可能没时间、没必要或水平不够，但是不要把这些都看成黑盒，代码都是一行一行敲出来的，即便再底层的东西，它也是实实在在的代码，最多不过0和1，不要求我弄懂所有源码，但是基本的思想还是可以去查一些相关资料了解一下的，了解了基本原理学起来才事半功倍，甚至不学胜有学，因为你无非就是那样去实现的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference">JavaScript 参考</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/Shd-Study/p/6560808.html">javascript中call()、apply()、bind()的用法终于理解</a></p>
</li>
<li><p><a href="https://juejin.cn/post/6844903567967387656">让你弄懂 call、apply、bind的应用和区别</a></p>
</li>
<li><p><a href="https://www.zhihu.com/question/20289071/answer/93261557">如何理解和熟练运用 JS 中的 call 及 apply？</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/zhazhanitian/p/11400898.html">call、apply、bind的原理剖析及实现</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo 使用</title>
    <url>/2021/02/10/%E6%8A%80%E6%9C%AF/Hexo%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Hexo-使用"><a href="#Hexo-使用" class="headerlink" title="Hexo 使用"></a>Hexo 使用</h1><p>官方文档：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p>
<h2 id="快速开始"><a href="#快速开始" class="headerlink" title="快速开始"></a>快速开始</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br>hexo init [folder]<br><span class="hljs-built_in">cd</span> [folder]<br>npm install<br><span class="hljs-comment"># 生成文档</span><br>hexo g<br><span class="hljs-comment"># 启动服务</span><br>hexo s<br></code></pre></td></tr></table></figure>
<p>访问：<a href="http://localhost:4000/">http://localhost:4000</a></p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 初始化</span><br>hexo init [folder]<br><span class="hljs-comment"># 生成</span><br>hexo g|generate<br><span class="hljs-comment"># 启动服务</span><br>hexo s|server<br><span class="hljs-comment"># 发布</span><br>hexo d|deploy<br><span class="hljs-comment"># 清除</span><br>hexo clean<br></code></pre></td></tr></table></figure>
<h2 id="基本设置"><a href="#基本设置" class="headerlink" title="基本设置"></a>基本设置</h2><p>配置文件为 <code>_config.yml</code></p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># 博客标题</span><br><span class="hljs-attr">title:</span> <span class="hljs-string">&quot;SharonLee&#x27;s Blog&quot;</span><br><span class="hljs-comment"># 副标题</span><br><span class="hljs-attr">subtitle:</span> <br><span class="hljs-comment">#网站描述</span><br><span class="hljs-attr">description:</span> <br><span class="hljs-comment">#作者昵称</span><br><span class="hljs-attr">author:</span> <span class="hljs-string">SharonLee</span><br><span class="hljs-comment"># 设置语言</span><br><span class="hljs-attr">language:</span> <span class="hljs-string">zh-CN</span><br><span class="hljs-comment"># 时区</span><br><span class="hljs-attr">timezone:</span> <span class="hljs-string">Asia/Shanghai</span><br><br><span class="hljs-comment"># 设置主题</span><br><span class="hljs-attr">theme:</span> <span class="hljs-string">next</span><br></code></pre></td></tr></table></figure>
<h2 id="发布到-Git"><a href="#发布到-Git" class="headerlink" title="发布到 Git"></a>发布到 Git</h2><p>安装依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install hexo-deployer-git --save<br></code></pre></td></tr></table></figure>
<p>配置：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">&lt;repository</span> <span class="hljs-string">url&gt;</span><br>  <span class="hljs-attr">branch:</span> [<span class="hljs-string">branch</span>]<br></code></pre></td></tr></table></figure>
<h2 id="NexT-主题"><a href="#NexT-主题" class="headerlink" title="NexT 主题"></a>NexT 主题</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>github 地址：<a href="https://github.com/theme-next/hexo-theme-next">https://github.com/theme-next/hexo-theme-next</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next <span class="hljs-comment"># 删除 .git 文件夹</span><br><span class="hljs-comment"># 或者下载解压到相应目录</span><br></code></pre></td></tr></table></figure>
<p><code>_config.yml</code> 中配置主题</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">theme:</span> <span class="hljs-string">next</span><br></code></pre></td></tr></table></figure>
<h3 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h3><p><code>next/_config.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 字体小一点</span><br><span class="hljs-attr">font:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">global:</span><br>  	<span class="hljs-attr">size:</span> <span class="hljs-number">0.8</span><br>  	<br><span class="hljs-comment"># 样式</span><br><span class="hljs-attr">scheme:</span> <span class="hljs-string">Gemini</span><br><br><span class="hljs-comment"># 展开所有目录</span><br><span class="hljs-attr">toc:</span><br>  <span class="hljs-attr">expand_all:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<h3 id="开启分类、标签和关于"><a href="#开启分类、标签和关于" class="headerlink" title="开启分类、标签和关于"></a>开启分类、标签和关于</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">hexo new page tags<br>hexo new page categories<br>hexo new page about<br></code></pre></td></tr></table></figure>
<p><code>source/xxx/index.md</code> 中分别添加</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">type:</span> <span class="hljs-string">tags</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">categories</span><br><span class="hljs-attr">type:</span> <span class="hljs-string">about</span><br></code></pre></td></tr></table></figure>
<p>配置 <code>next/_config.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">menu:</span><br>  <span class="hljs-attr">about:</span> <span class="hljs-string">/about/</span> <span class="hljs-string">||</span> <span class="hljs-string">user</span><br>  <span class="hljs-attr">tags:</span> <span class="hljs-string">/tags/</span> <span class="hljs-string">||</span> <span class="hljs-string">tags</span><br>  <span class="hljs-attr">categories:</span> <span class="hljs-string">/categories/</span> <span class="hljs-string">||</span> <span class="hljs-string">th</span><br></code></pre></td></tr></table></figure>
<h3 id="开启搜索"><a href="#开启搜索" class="headerlink" title="开启搜索"></a>开启搜索</h3><p>安装依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install hexo-generator-searchdb --save<br></code></pre></td></tr></table></figure>
<p>配置 <code>next/_config.yml</code>：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">local_search:</span><br>  <span class="hljs-attr">enable:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<h2 id="文章头"><a href="#文章头" class="headerlink" title="文章头"></a>文章头</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">tag:</span> <span class="hljs-string">标签</span><br><span class="hljs-attr">category:</span> <span class="hljs-string">分类</span><br><span class="hljs-attr">description:</span> <span class="hljs-string">描述</span> <span class="hljs-comment"># 有描述则首页显示描述，否则显示全部，或者显示到 &lt;!-- more --&gt;</span><br></code></pre></td></tr></table></figure>
<h2 id="截取"><a href="#截取" class="headerlink" title="截取"></a>截取</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install hexo-excerpt --save<br></code></pre></td></tr></table></figure>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">excerpt:</span><br>  <span class="hljs-attr">depth:</span> <span class="hljs-number">10</span><br>  <span class="hljs-attr">excerpt_excludes:</span> []<br>  <span class="hljs-attr">more_excludes:</span> []<br>  <span class="hljs-attr">hideWholePostExcerpts:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<h2 id="GitHub-Actions-发布"><a href="#GitHub-Actions-发布" class="headerlink" title="GitHub Actions 发布"></a>GitHub Actions 发布</h2><p><code>.github/workflows/main.yml</code></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span> <span class="hljs-string">GitHub</span> <span class="hljs-string">Pages</span><br><br><span class="hljs-comment"># 触发条件：在 push 到 master 分支后</span><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">master</span><br><br><span class="hljs-comment"># 任务</span><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build-and-deploy:</span><br>    <span class="hljs-comment"># 服务器环境：最新版 Ubuntu</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-comment"># 拉取代码</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v2.3.1</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">persist-credentials:</span> <span class="hljs-literal">false</span><br><br>      <span class="hljs-comment"># 1、生成静态文件</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span> <span class="hljs-string">&amp;&amp;</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">build</span><br><br>      <span class="hljs-comment"># 2、部署到 GitHub Pages</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Deploy</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">JamesIves/github-pages-deploy-action@4.0.0</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">branch:</span> <span class="hljs-string">gh-pages</span><br>          <span class="hljs-attr">folder:</span> <span class="hljs-string">public</span><br>          <span class="hljs-comment">#注意这里的 public 是仓库根目录下的 public，也就是 npm run build 生成静态资源的路径，比如有的人是 `docs/.vuepress/dist`</span><br><br>      <span class="hljs-comment"># 3、同步到 gitee 的仓库</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Sync</span> <span class="hljs-string">to</span> <span class="hljs-string">Gitee</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">wearerequired/git-mirror-action@v1</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-comment"># 注意在 Settings-&gt;Secrets 配置 GITEE_RSA_PRIVATE_KEY</span><br>          <span class="hljs-attr">SSH_PRIVATE_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITEE_RSA_PRIVATE_KEY</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-comment"># 注意替换为你的 GitHub 源仓库地址</span><br>          <span class="hljs-attr">source-repo:</span> <span class="hljs-string">git@github.com:linception/linception.github.io.git</span><br>          <span class="hljs-comment"># 注意替换为你的 Gitee 目标仓库地址</span><br>          <span class="hljs-attr">destination-repo:</span> <span class="hljs-string">git@gitee.com:sharonlee/sharonlee.git</span><br><br>      <span class="hljs-comment"># 4、部署到 Gitee Pages</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Build</span> <span class="hljs-string">Gitee</span> <span class="hljs-string">Pages</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">yanglbme/gitee-pages-action@main</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-comment"># 注意替换为你的 Gitee 用户名</span><br>          <span class="hljs-attr">gitee-username:</span> <span class="hljs-string">sharonlee</span><br>          <span class="hljs-comment"># 注意在 Settings-&gt;Secrets 配置 GITEE_PASSWORD</span><br>          <span class="hljs-attr">gitee-password:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.GITEE_PASSWORD</span> <span class="hljs-string">&#125;&#125;</span><br>          <span class="hljs-comment"># 注意替换为你的 Gitee 仓库，仓库名严格区分大小写，请准确填写，否则会出错</span><br>          <span class="hljs-attr">gitee-repo:</span> <span class="hljs-string">sharonlee/sharonlee</span><br>          <span class="hljs-comment"># 要部署的分支，默认是 master，若是其他分支，则需要指定（指定的分支必须存在）</span><br>          <span class="hljs-attr">branch:</span> <span class="hljs-string">master</span><br></code></pre></td></tr></table></figure>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><h3 id="方式一"><a href="#方式一" class="headerlink" title="方式一"></a>方式一</h3><p>图片全放在 <code>source/images</code> 下，以绝对路径方式引用 <code>/images/xxx.png</code>，同时 typora <code>格式-&gt;图像-&gt;设置图片根目录</code> 设置为 <code>source</code> 目录</p>
<h3 id="方式二"><a href="#方式二" class="headerlink" title="方式二"></a>方式二</h3><p>设置 <code>post_asset_folder: true</code>，图片存放在 <code>filename</code> 文件夹下，这样图片会被拷贝到文件同级目录</p>
<p>再安装下面插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">npm install hexo-asset-image --save<br>npm install hexo-simple-image --save<br>npm install hexo-typora-image --save<br>npm install hexo-image-link --save<br></code></pre></td></tr></table></figure>
<p>最简单是用预装的 <code>hexo-renderer-marked</code> 插件，直接配置</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">marked:</span><br>  <span class="hljs-attr">prependRoot:</span> <span class="hljs-literal">true</span><br>  <span class="hljs-attr">postAsset:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>
<h3 id="方式三"><a href="#方式三" class="headerlink" title="方式三"></a>方式三</h3><figure class="highlight django"><table><tr><td class="code"><pre><code class="hljs django"><span class="hljs-template-tag">&#123;% <span class="hljs-name">asset_img</span> image_name.jpg This is an image %&#125;</span><br></code></pre></td></tr></table></figure>
<blockquote>
<p>不爽的地方：</p>
<ol>
<li>必须建立一个与文件名同名的文件夹存放资源，<code>post_asset_folder</code> 设置才会拷贝</li>
<li>文件名不能有空格，不过 title 可以有，并且可以不和文件名一致</li>
</ol>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li><p><a href="https://hexo.io/zh-cn/docs/">官方文档</a></p>
</li>
<li><p><a href="https://hexo.io/zh-cn/docs/asset-folders.html">资源文件夹</a></p>
</li>
<li><p><a href="https://blog.csdn.net/mqdxiaoxiao/article/details/93644533">Hexo博客NexT主题下添加分类、标签、关于菜单项</a></p>
</li>
<li><p><a href="https://jishuin.proginn.com/p/763bfbd38928">GitHub Actions入门教程：自动化部署静态博客</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1702112">hexo 图片显示问题及使用typora设置图片路径</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>数值在计算机中的表示</title>
    <url>/2021/02/12/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/%E6%95%B0%E5%80%BC%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E8%A1%A8%E7%A4%BA/</url>
    <content><![CDATA[<h1 id="数值在计算机中的表示"><a href="#数值在计算机中的表示" class="headerlink" title="数值在计算机中的表示"></a>数值在计算机中的表示</h1><h2 id="原码、反码、补码"><a href="#原码、反码、补码" class="headerlink" title="原码、反码、补码"></a>原码、反码、补码</h2><p><strong>原码</strong>：最高位是符号位，0为正，1为负，其余为该二进制的绝对值</p>
<p><strong>反码</strong>：原码符号位不变，其余按位取反</p>
<p><strong>补码</strong>：两种计算方式</p>
<ol>
<li>反码+1</li>
<li>右边第一个1及其右边的0不变，左边按位取反</li>
</ol>
<blockquote>
<p>计算机中都是存的补码，上面只是补码的计算方式，不是定义</p>
</blockquote>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><p>补码的出现，就是为了把减法变成加法。怎么变呢，我们以钟表为例，一圈刻度是0到11。如果要从10点回拨到8点：</p>
<ol>
<li>一种方式是直接-2</li>
<li>另一个方式是+10</li>
</ol>
<p>10怎么来的？10其实也是回拨2，只不过是在多一圈的基础上-2，即10=12-2，这里的10就类似于2的补码。</p>
<p>计算机中的补码根本原因就是因为n位二进制溢出循环机制类似于钟表循环：</p>
<ul>
<li>减一个数m等于加上-m+2^(n+1)的正数</li>
<li>反过来，加一个数m等于加一个m-2^(n+1)的负数</li>
</ul>
<p>根据下图，加左边的数就等于减去对应的补码</p>
<p><img src="/images/image-20210213021329311.png" alt="补码理解"></p>
<blockquote>
<p>总结来说，补码就是2^(n+1)-m</p>
<ul>
<li>加上你的补码就是减去你</li>
<li>虽然和你背靠背，那我绕地球一圈就是和你面对面</li>
</ul>
</blockquote>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.imooc.com/article/16813?block_id=tuijian_wz">原码，反码，补码杂谈</a></li>
</ul>
<h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>IEEE（Institute of Electrical and Electronics Engineers，电气与电子工程师协会）标准浮点数表示：<code>V=(-1)^s * M * 2^E</code></p>
<ul>
<li>S：符号（Sign），0 正，1 负</li>
<li>E：阶码（Exponent），2 的 E 次幂，可能是负数</li>
<li>M：尾数（Mantissa），二进制小数，[1,2) 或 [0,1)</li>
</ul>
<p>单精度浮点数：</p>
<p><img src="/images/20210214002202.png" alt="单精度浮点数表示"></p>
<p>双精度浮点数：</p>
<p><img src="/images/20210214002210.png" alt="双精度浮点数表示"></p>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>根据阶码和尾数的不同，可以分为几类：</p>
<p><img src="/images/image-20210214002715305.png" alt="浮点数值分类"></p>
<ul>
<li><p>规格化的值：e 不全为0和1，E=e-Bias，M=m+1</p>
<blockquote>
<p>k 位阶码，偏置（Bias）为 2^(k-1)-1</p>
<ul>
<li>单精度 k 为8，偏置为127</li>
<li>双精度 k 为 11，偏置为1023</li>
</ul>
</blockquote>
</li>
<li><p>非规格化的值：e 全为0，E=1-Bias，M=m</p>
<blockquote>
<p><strong>为什么非规格化 E=1-Bias，而不是 -Bias</strong>：因为和规则化的值平滑衔接</p>
<p><strong>为什么需要非规则化的值</strong>：</p>
<ul>
<li>因为规格化整数位始终是1，即 M&gt;=1，不能表示0。阶码和尾数全为0，分正负</li>
<li>表示非常接近0的数</li>
</ul>
</blockquote>
</li>
<li><p>无穷：e 全为1，m 全为0，分正负</p>
</li>
<li><p>NaN：e 全为1，m 不为0，是一系列值</p>
</li>
</ul>
<h3 id="参考-1"><a href="#参考-1" class="headerlink" title="参考"></a>参考</h3><ul>
<li><p><a href="https://blog.csdn.net/tercel_zhang/article/details/52537726">程序员必知之浮点数运算原理详解</a></p>
</li>
<li><p><a href="http://c.biancheng.net/view/314.html">IEEE 754浮点数标准详解</a></p>
</li>
<li><p><a href="https://zhuanlan.zhihu.com/p/107106675">IEEE浮点表示</a></p>
</li>
<li><p>《深入理解计算机系统（第3版）》</p>
</li>
<li><p>《计算机科学导论（第3版）》</p>
</li>
<li><p><a href="http://www.binaryconvert.com/result_float.html">浮点在线数转二进制</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机基础</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
      </tags>
  </entry>
</search>
